# JSON.stringify
    1.JSON.stringify(myperson, ['name'])第二个参数是数组时，数组传入需要转化成字符串的键
    2.  let Jsonperson = JSON.stringify(myperson, (key, value) => {
            if (key === 'sex') {
                return undefined
            }
        return value
    })
    第二个参数是方法时，第一个形参是键，第二个形参是值
    3.第三个参数是转化成字符串时，每级键值的缩进
    4.在对象里面使用toJSON()方法，可以在用户toStringfy弹出提醒并阻止转化
# 手写Promise要点(处理回调地狱)
    1.如何获取resolve或者rejected的值?
        将值放入Promise实例对象PromiseResult中，然后.then方法通过this获取到PromiseResult
    2..then方法如何实现异步?
        第一次执行时不会修改PromiseState的值,值依然为pedding,.then执行时发现PromiseState的值为pedding,将自身的onResolved,
        onRejected放入实例对象的回调数组中,当resolve和reject执行后再执行回调数组里面的方法
    3.Promise是如何拦截错误的?
        使用try{}catch()将Promise的方法调用,如果抛出错误则执行catch(),返回reject
    4.如何串联多个任务.then().then()
        .then方法返回一个new Promise(),再通过try{}catch(){}捕获错误
    5.异常穿透
        .catch(),如果上面的.then方法没有返回reject,会直接返回,如何实现?只调用.then方法的第二个方法
    6.如何中断Promise链
        状态返回pedding,具体操作就是返回Promise,不使用resolve和reject
    7.resolve和reject实现
        reslove里面返回一个promise,然后判断传进去的是promise还是普通数值,如果是promise还需要判断返回的是reslove还是reject
        reject返回的就是传入的内容,无论是普通数值还是promise
    8.all方法实现
        返回的数组必须按顺序,通过arr[i]方法传入值
    9.race方法实现
        谁先执行返回谁
# BFC
    1.一个独立的块级盒子,箱子里面的元素永远不会影响外部
    2.应用:解决浮动塌陷问题,解决margin值重叠问题,给它们添加一个父级然后给父级使用bfc
    3.如何触发?
        float:除none以外的值
        position:absolut和fixed
        display为inline-block、flex、table-cell、inline-flex、table-caption
        overflow除了visible以外的值（hidden、auto、scroll）
# fixed出现错误
    1.当父元素拥有transform时,子元素的position:fixed将不会相对于窗口定位,而是会相对于父元素定位
# 为什么不推荐使用style内联元素
    1.因为style是节点的属性,不能被缓存;代码的可读性和维护性相对弱
# 如何实现继承
    1.组合式继承,在children的类中通过call调用parents,后面再传入对应的参数,再将children.prototype = new Parents()
    2.寄生式组合继承,在children的类中通过call调用parents,再将children.prototype = Object.create(Parents.prototype),children.prototype.constructor = Children
    3.Class
# call,aplly,bind原理
    1.将函数放入传入的obj中,再将其调用,最后需要使用delete删除obj中传入的函数,call和aplly都是这样
    2.bind是深度复制obj,然后给复制的obj添加传入的函数,再将复制的obj里面的函数返回
# 深浅拷贝
    1.浅拷贝(对象的:object.assign(),数组的:[],都有:...)
    2.深拷贝(数组和对象的:JSON.parse(),递归)
# 书写ajax
    function myajax(method,url,callback){
        let xhr = new XMLHttpRequest()
        xhr.open(method,url)
        xhr.send()
        xhr.onreadystatechange = function(){
            if(xhr.readyState === 4){
                if(xhr.status >= 200 && xhr.status < 300){
                    let res = JSON.parse(xhr.response)
                    callback(res.result)
                }
            }
        }
    }
# ES6,ES7新特性
    1.定义:let,const
    2.symbol,bigInt
    3.解构,扩展运算符,Promise,模板字符串,module,Class,for-of,Map,Set,箭头函数
    4.对象:Object.is(),Object.assign(),Object.key(),Object.value(),Object.getOwnPropertyNames(),Object.entries()
        Object.is()能够判断两个值是否是相同的值(Object.is能判断两个undefined,null,相同的字符串)
        Object.key和Object.getOwnPropertyNames区别,前者返回所有可枚举的属性,后者是全部属性
        Object.entries能够将obj转化成二维数组([[key,value],[key,value]])
    5.数组:forEach,filter,map,reduce,every,some,fill,from,isArray,find,findIndex,includes
        forEach和map和filter区别,forEach没有返回值,而map和filter的返回值是数组,遍历时如果map没有返回则为undefined,而filter起到一个筛选作用,返回的数组里面的值取决于遍历时返回的值
        every:只要有一个false,则返回false
        some:只要有一个true,则返回true
        Array.isArray:判断是否为数组
        find:找到第一个符合要求的值就结束遍历,返回那个值
        findIndex:找到第一个符合要求的值就结束遍历,返回那个值的下标
        includes:判断是否包含传入的值,包含返回true,否则返回false
        fill:填充数组 new Array(8).fill
# Object.defineProperty,Object.defineProperties区别
    前者添加监听,后者给对象添加值.用法不同,前者三个参数,第二个参数是监听的值{obj,'name',{get(){}}}.后者只有两个参数,第二个参数为对象{obj,name:{}}
# 防抖节流
    1.防抖:规定时间后没有新的变动才会执行
    2.节流:规定时间内多次点击只会执行一次
# HTML5新特性
    1.语义化标签（header（表示文档的头部区域），footer（表示文档的尾部区域），nav（表示文档导航部分），section（表示文档的某一节），article（表示文章），main（表示文档主要的内容区域））
    2.增强性表单(number，date，url，placeholder，required)
    3.媒体元素（audio，video）
    4.canvas绘图
    5.Web Storage
    5.svg绘图
# 如何检测一个对象一定是数组
    1.Object.prototype.toString.call()
    2.instanceof(原理：右边的原型是否在左边的原型链上)
    3.Array.isArray()
# 转化规则（隐式转化规则）
    1.“==”只判断两边值是否相同，“===”还需要判断两边类型是否相同
    2.undefined 与 null 比较特殊,要比较相等性之前,不能将 null 和 undefined 转换成其他任何值
        undefiend == undefined　　 //　true
        undefined == null　　      //　true
        null == null　　           //　true
        undefined == 其他值　　    //　false
        null == 其他值　　         //　false  
    3.NaN（非数值）也很特殊，NaN 和任何值（包括自己）比较都是返回 false
    4.等号两侧为相同的引用数据类型时，由于引用类型保存的是对象（包括数组，函数）的地址值，所以地址值不同的，返回的都是 false
    5.只有一侧为引用数据类型时，都转化成数字
        [1，2] == 1　　   ==>　　NaN == 1　　      //　false
        [1，2] == true　　==>　　NaN == 1　　      //　false
        [1] == 1　　      ==>　　1 == 1　　        //　true
        [1] == '1'　　    ==>　　'1' == '1'　　    //　true
    如何记忆（当1层的对象类型与2层字符串进行比较，会将对象类型隐式转化为字符串类型，进行比较；当2层的字符串类型或布尔类型与数值类型进行比较，会将2层的类型隐式转化为数值类型，进行比较；当1层的对象类型与3层的数值类型进行比较，会先将对象类型转化为字符串类型再转化为数值类型；当2层的类型相互比较，会均转化为数值类型再进行比较；）
# toString和valueOf区别（当数字或对象需要隐式转换时，比如==，此时会用到对象上面的 toString,valueOf方法转换。）
    正常情况下，先掉用toString，当存在运算符时，优先调用valueOf，当发现value运算不了时，还是会再次调用tostring
    1.toString函数的作用是把一个逻辑值转为字符串
    2.valueOf函数是用来返回最适合引用类型的原始值。如果没有原始值，就返回引用类型本身。
    3.valueOf偏向于运算，toString偏向于展示