# JSON.stringify
    1.JSON.stringify(myperson, ['name'])第二个参数是数组时，数组传入需要转化成字符串的键
    2.  let Jsonperson = JSON.stringify(myperson, (key, value) => {
            if (key === 'sex') {
                return undefined
            }
        return value
    })
    第二个参数是方法时，第一个形参是键，第二个形参是值
    3.第三个参数是转化成字符串时，每级键值的缩进
    4.在对象里面使用toJSON()方法，可以在用户toStringfy弹出提醒并阻止转化
# 手写Promise要点(处理回调地狱)
    1.如何获取resolve或者rejected的值?
        将值放入Promise实例对象PromiseResult中，然后.then方法通过this获取到PromiseResult
    2..then方法如何实现异步?
        第一次执行时不会修改PromiseState的值,值依然为pedding,.then执行时发现PromiseState的值为pedding,将自身的onResolved,
        onRejected放入实例对象的回调数组中,当resolve和reject执行后再执行回调数组里面的方法
    3.Promise是如何拦截错误的?
        使用try{}catch()将Promise的方法调用,如果抛出错误则执行catch(),返回reject
    4.如何串联多个任务.then().then()
        .then方法返回一个new Promise(),再通过try{}catch(){}捕获错误
    5.异常穿透
        .catch(),如果上面的.then方法没有返回reject,会直接返回,如何实现?只调用.then方法的第二个方法
    6.如何中断Promise链
        状态返回pedding,具体操作就是返回Promise,不使用resolve和reject
    7.resolve和reject实现
        reslove里面返回一个promise,然后判断传进去的是promise还是普通数值,如果是promise还需要判断返回的是reslove还是reject
        reject返回的就是传入的内容,无论是普通数值还是promise
    8.all方法实现
        返回的数组必须按顺序,通过arr[i]方法传入值
    9.race方法实现
        谁先执行返回谁
# BFC
    1.一个独立的块级盒子,箱子里面的元素永远不会影响外部
    2.应用:解决浮动塌陷问题,解决margin值重叠问题,给它们添加一个父级然后给父级使用bfc
    3.如何触发?
        float:除none以外的值
        position:absolut和fixed
        display为inline-block、flex、table-cell、inline-flex、table-caption
        overflow除了visible以外的值（hidden、auto、scroll）
# fixed出现错误
    1.当父元素拥有transform时,子元素的position:fixed将不会相对于窗口定位,而是会相对于父元素定位
# 为什么不推荐使用style内联元素
    1.因为style是节点的属性,不能被缓存;代码的可读性和维护性相对弱
# 如何实现继承
    1.组合式继承,在children的类中通过call调用parents,后面再传入对应的参数,再将children.prototype = new Parents()
    2.寄生式组合继承,在children的类中通过call调用parents,再将children.prototype = Object.create(Parents.prototype),children.prototype.constructor = Children
    3.Class
# call,aplly,bind原理
    1.将函数放入传入的obj中,再将其调用,最后需要使用delete删除obj中传入的函数,call和aplly都是这样
    2.bind是深度复制obj,然后给复制的obj添加传入的函数,再将复制的obj里面的函数返回
# 深浅拷贝
    1.浅拷贝(对象的:object.assign(),数组的:[],都有:...)
    2.深拷贝(数组和对象的:JSON.parse(),递归)
# 书写ajax
    function myajax(method,url,callback){
        let xhr = new XMLHttpRequest()
        xhr.open(method,url)
        xhr.send()
        xhr.onreadystatechange = function(){
            if(xhr.readyState === 4){
                if(xhr.status >= 200 && xhr.status < 300){
                    let res = JSON.parse(xhr.response)
                    callback(res.result)
                }
            }
        }
    }
# ES6,ES7新特性
    1.定义:let,const
    2.symbol,bigInt
    3.解构,扩展运算符,Promise,模板字符串,module,Class,for-of,Map,Set,箭头函数
    4.对象:Object.is(),Object.assign(),Object.key(),Object.value(),Object.getOwnPropertyNames(),Object.entries()
        Object.is()能够判断两个值是否是相同的值(Object.is能判断两个undefined,null,相同的字符串)
        Object.key和Object.getOwnPropertyNames区别,前者返回所有可枚举的属性,后者是全部属性
        Object.entries能够将obj转化成二维数组([[key,value],[key,value]])
    5.数组:forEach,filter,map,reduce,every,some,fill,from,isArray,find,findIndex,includes
        forEach和map和filter区别,forEach没有返回值,而map和filter的返回值是数组,遍历时如果map没有返回则为undefined,而filter起到一个筛选作用,返回的数组里面的值取决于遍历时返回的值
        every:只要有一个false,则返回false
        some:只要有一个true,则返回true
        Array.isArray:判断是否为数组
        find:找到第一个符合要求的值就结束遍历,返回那个值
        findIndex:找到第一个符合要求的值就结束遍历,返回那个值的下标
        includes:判断是否包含传入的值,包含返回true,否则返回false
        fill:填充数组 new Array(8).fill
# Object.defineProperty,Object.defineProperties区别
    前者添加监听,后者给对象添加值.用法不同,前者三个参数,第二个参数是监听的值{obj,'name',{get(){}}}.后者只有两个参数,第二个参数为对象{obj,name:{}}
# 防抖节流
    1.防抖:规定时间后没有新的变动才会执行
    2.节流:规定时间内多次点击只会执行一次
# HTML5新特性
    1.语义化标签（header（表示文档的头部区域），footer（表示文档的尾部区域），nav（表示文档导航部分），section（表示文档的某一节），article（表示文章），main（表示文档主要的内容区域））
    2.增强性表单(number，date，url，placeholder，required)
    3.媒体元素（audio，video）
    4.canvas绘图
    5.Web Storage
    5.svg绘图
# 如何检测一个对象一定是数组
    1.Object.prototype.toString.call()
    2.instanceof(原理：右边的原型是否在左边的原型链上)
    3.Array.isArray()
# 转化规则（隐式转化规则）
    1.“==”只判断两边值是否相同，“===”还需要判断两边类型是否相同
    2.undefined 与 null 比较特殊,要比较相等性之前,不能将 null 和 undefined 转换成其他任何值
        undefiend == undefined　　 //　true
        undefined == null　　      //　true
        null == null　　           //　true
        undefined == 其他值　　    //　false
        null == 其他值　　         //　false  
    3.NaN（非数值）也很特殊，NaN 和任何值（包括自己）比较都是返回 false
    4.等号两侧为相同的引用数据类型时，由于引用类型保存的是对象（包括数组，函数）的地址值，所以地址值不同的，返回的都是 false
    5.只有一侧为引用数据类型时，都转化成数字
        [1，2] == 1　　   ==>　　NaN == 1　　      //　false
        [1，2] == true　　==>　　NaN == 1　　      //　false
        [1] == 1　　      ==>　　1 == 1　　        //　true
        [1] == '1'　　    ==>　　'1' == '1'　　    //　true
    如何记忆（当1层的对象类型与2层字符串进行比较，会将对象类型隐式转化为字符串类型，进行比较；当2层的字符串类型或布尔类型与数值类型进行比较，会将2层的类型隐式转化为数值类型，进行比较；当1层的对象类型与3层的数值类型进行比较，会先将对象类型转化为字符串类型再转化为数值类型；当2层的类型相互比较，会均转化为数值类型再进行比较；）
# toString和valueOf区别（当数字或对象需要隐式转换时，比如==，此时会用到对象上面的 toString,valueOf方法转换。）
    正常情况下，先掉用toString，当存在运算符时，优先调用valueOf，当发现value运算不了时，还是会再次调用tostring
    1.toString函数的作用是把一个逻辑值转为字符串
    2.valueOf函数是用来返回最适合引用类型的原始值。如果没有原始值，就返回引用类型本身。
    3.valueOf偏向于运算，toString偏向于展示
# javascrip有几种类型的值，如何存储的？
    1.基本数据类型，引用数据类型
    2.基本数据类型存放在栈中，引用数据的类型的值存放在堆中，但他们的地址值存放在栈中
# 内部属性 [[Class]] 是什么？
```
所有 typeof 返回值为 "object" 的对象（如数组）都包含一个内部属性 [[Class]]（我们可以把它看作一个内部的分类，而非
传统的面向对象意义上的类）。这个属性无法直接访问，一般通过 Object.prototype.toString(..) 来查看。
如何自己定义？
class myclass{
    get[Symbol.toStringTag](){
        return 'myclass'
    }
}
let myclass = new Class2()
console.log(Object.prototype.toString.call(new myclass()))
```
# js有哪些内置对象
```
1.值属性：Infinity:比任何有限数都大，NaN，undefined，null字变量
2.函数属性：eval(),parseFloat(),parseInt()
3.基本对象：Object,Function,Boolean,Symbol,Error
```
# undefined 与 undeclared 的区别
```
undefined是已定义未赋值，undeclared是未定义却使用
```
# null 和 undefined 的区别
```
null是用户主动赋值的，undefined是系统赋值的
```
# 如何安全的获取undefined
```
使用void
```
# JavaScript基本规范
```
1.声明变量时，不能出现连续的两个var声明，如果变量没有值，应该给变量赋值对应类型的初始值
2.进行比较时尽量用 ===
3.不要在内置对象的原型上添加方法，如Array，Date
4.switch语句必须有default分支
```
# JavaScript 原型，原型链？
```
1.js中我们是用构造函数创建一个对象的，每个构造函数的内部都含有prototype属性值，当我们使用构造函数
创建一个对象时，这个对象的_proto_指向构造函数的prototype属性的对应的值，这个值被成为对象的原型
2.原型链：当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会通过_proto_找这个属性，
那么它就会去它的原型对象里找这个属性，直到找到原型链的尽头：Object.prototype._proto_,它是指向null的
```
# JS获取原型的方法
```
1.p._proto_
2.p.constructor.prototype
3.Object.getPrototypeOf()
```
# js 中整数的安全范围是多少
```
2^53-1
```
# typeof NaN值为什么,isNaN 和 Number.isNaN 函数的区别？
```
1.值为number
2.NaN != NaN // true
3.isNaN是所有不能转化成数字的值都会返回true
4.Number.isNaN是先判断传入参数是否为数字,如果是数字再判断是否为NaN,这种方法更准确判断是否是NaN
```
# Array构造函数只有一个参数时的表现
```
只有一个参数时,那个参数决定的生成数组的长度
构造函数 Array(..) 不要求必须带 new 关键字。不带时，它会被自动补上。
```
# 其他值到字符串的转换规则
```
null转化成'null',undefined转化成'undefined',true 转换为 "true"，false 转换为 "false",Number 类型的值直接转换，不过那些极小和极大的数字会使用指数形式.Symbol类型的值会转化成[object Symbol]
```
# 其他值到数字值的转化规则
```
1.Undefined=>NaN
2.null转化为0
3.String类型的值和Number()转换一样
4.Symbol不能转换,否则会报错
5.Boolean类型的值,true转换为1,false转换为0
6.对象(包括数组)会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字
```
# 其他值到布尔值的转化规则
```
假值:undefined,null,false,+0,-0,NaN,''
除假值外其他都是真值
```
# {} 和 [] 的 valueOf 和 toString 的结果是什么？
```
1.{}的valueOf值为{},[]为[]
2.{}的toString值为[object,object],[]的值为''
```
# 假值对象:就是假值,布尔值为false的对象
常见的假值对象为document.all
# ~操作符的作用？
```
我们可以使用~来进行取反操作
~x相当于-(x+1)
```