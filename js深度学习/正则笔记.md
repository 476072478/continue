# 体验正则表达式
```
提取mystr='121231dwad'中的数值
1.传统方法  [...mystr].filter(item => !Number.isNaN(parseInt(item))).join('')
2.正则方法  mystr.match(/\d/g).join('')
```
# 字面量创建正则表达式
```
1.字面量方式,需要找d,直接/d/ 缺点是不能操作变量
2.需要操作变量的时候,使用eval将正则变成js语法
    let a = 'd'
    eval(`/${a}/`).test(mystr)
```
# 使用对象创建正则表达式
```
1.new RegExp('u','g') //找字母u,全局匹配
2.new RegExp(u,'g') //找变量u,全局匹配
```
# 选择符的使用
```
/a|b/ a或者b
let phonenumber = '010-99999999'
let isphone = /^(010|020)\-\d{7,8}$/
isphone.test(phonenumber) // true 
例：检测电话号码
```
# 原子表和原子组中的选择符
```
1.[]原子表
2.()原子组
/[1234567]/ 表示 /1|2|3|4|5|6|7/
/(12|34)/ 表示 12是整体或者34是整体,不会单独匹配一个1
[^]里面有^表示除了它们都要
```
# 转义的理解
```
例：找到23.45
/^\d+\.\d+$/
字面量里不能直接写. .表示除换行外任何字符和普通点 \.表示普通点
但在对象里不能只写一个\,因为经过编译后\就消失了,例如 \d+\.\d+ => d+.d+,所以需要两个\\
new RegExp(^\\d+\\.\\d+$)
```
# 字符边界约束
```
^表示以什么开始
$表示以什么结束
例子：匹配a到z的3到6位字母
.match(/^[a-z]{3,6}$/)
```
# 数值和空白元字符(大写的是反向的)
```
\d:匹配数字
\s:空白
```